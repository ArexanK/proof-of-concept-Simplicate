import { Reflection as Reflect } from '@abraham/reflection';
import { attributeNameFromProperty, privatePropertyName } from './utils';
const primitiveTypes = [Boolean, Number, String];
function isPrimitive(type) {
    return primitiveTypes.includes(type);
}
function alreadyObserved(target, name, type) {
    return target.constructor[observeType(type)].includes(name);
}
function observeType(type) {
    return isPrimitive(type) ? 'observedAttributes' : 'observedProperties';
}
function observeName(prop, type) {
    return isPrimitive(type) ? attributeNameFromProperty(prop) : prop;
}
function observe(target, name, type) {
    if (!alreadyObserved(target, name, type)) {
        target.constructor[observeType(type)].push(observeName(name, type));
    }
}
function getter(name, type) {
    const attributeName = attributeNameFromProperty(name);
    return function () {
        switch (type) {
            case String:
                return this.getAttribute(attributeName);
            case Number:
                if (this.hasAttribute(attributeName)) {
                    return Number(this.getAttribute(attributeName));
                }
                else {
                    return null;
                }
            case Boolean:
                return this.hasAttribute(attributeName);
            default:
                return this[privatePropertyName(name)];
        }
    };
}
function setter(name, type) {
    const attributeName = attributeNameFromProperty(name);
    return function (value) {
        if (this._ignoreDefaultValue(name) && isPrimitive(type)) {
            this._ignoredDefaultAttributes[name] = true;
            return;
        }
        else if (!this._ignoredDefaultAttributes[name]) {
            this._ignoredDefaultAttributes[name] = true;
        }
        if (value === null || value === undefined || value === false || value === '') {
            this.removeAttribute(attributeName);
        }
        else {
            switch (type) {
                case String:
                    this.setAttribute(attributeName, String(value));
                    break;
                case Number:
                    this.setAttribute(attributeName, String(value));
                    break;
                case Boolean:
                    this.setAttribute(attributeName, '');
                    break;
                default:
                    this[privatePropertyName(name)] = value;
            }
        }
        this.render();
    };
}
export function property(options) {
    return function (target, name) {
        const type = (options && options.type) || Reflect.getMetadata('design:type', target, name);
        observe(target, name, type);
        Object.defineProperty(target, name, {
            configurable: true,
            enumerable: true,
            get: getter(name, type),
            set: setter(name, type),
        });
    };
}
//# sourceMappingURL=decorators.js.map